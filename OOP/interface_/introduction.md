## 接口
1. Go中**多态**特性是通过接口来体现的
2. 松耦合、高内聚

### 接口基本介绍
1. interface类型可以定义一组方法，但不能实现。并且interface类型**不能包含任何变量**
2. 实现接口必须实现接口的**所有方法**，仅实现其中几个不能算
3. 接口内的所有方法都**没有方法体**，即接口内都是没有实现的方法。接口体现了程序设计的
   **多态和高内聚低耦合**的思想
4. Go中的接口不是显式地实现，只要一个变量，含有接口类型中的所有方法，那么这个变量就算实现了
   这个接口。因此在Go中也可能一个结构体实现多个接口

### 接口基本语法
1. type 接口名 interface {
    method1(参数列表) (返回值列表)
    ...
}

### 接口的注意事项和细节
1. 接口不能直接创建实例，但是可以作为一个变量指向实现了该接口的自定义类型的实例
    - var usb Usb             // 编译错误
    - var phone Phone
      var usb Usb = phone       // 可以指向
2. 在Go中，一个自定义类型需要实现接口的所有方法，才能说该类型实现了这个接口
3. 只要是自定义类型，就可以实现接口，不一定是结构体
4. 一个自定义类型可以实现多个接口
5. Go接口中不能有任何变量
6. 接口也可以继承，如果A接口继承了B和C接口，那么要实现A接口，除了实现A中的方法，还要将B和C中
   所有的方法都实现
7. interface是**引用类型**
8. 空接口interface{}没有任何方法，所以所有类型都实现了空接口。所以空接口变量可以指向任何变量
9. 注意：结构体如果实现接口的方法时，传入的变量为指针类型，则空接口变量应指向(&结构体变量)，即
   指向地址。
    - 如: func (phone *Phone) Start() {...}
          func (phone *Phone) Stop() {...}
          var p Phone
          var usb Usb = &p      // 只能把Phone结构体变量的地址赋值给接口变量
10. 注意：实现接口的方法必须连参数列表和返回值列表都一样才算实现

### 接口和继承的关系
1. 当A结构体继承了B结构体，那么A结构体就自动继承了B结构体的所有字段和方法，可以直接使用
2. 当A结构体需要扩展功能，同时不希望破坏继承关系，则去实现某个接口即可。因此可以认为：**实现接口是
   对继承机制的补充**
3. 实现接口 **vs** 继承
    - 解决的问题不同：
        **继承的价值**在于：代码的**复用性和可维护性**
        **接口的价值**在于：**设计**，**规范**
    - 接口比继承**更灵活**
        *继承*是 is-a 的关系，*接口*是 like-a 的关系
    - 接口在一定程度上使**代码解耦**