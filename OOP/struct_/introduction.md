### Go面向对象编程说明
1. Go支持面向对象编程(OOP)，但不是纯粹的面向对象语言。即Go是**支持面向对象编程特性**的
2. Go中没有类(class)，在Go中，**结构体(struct)**和其他编程语言的类(class)是同等地位的。
   即Go是用结构体来实现OOP特性的
3. Go面向对象编程非常简洁，**去掉了**传统OOP语言的继承、方法重载、构造函数、析构函数和this
   指针等
4. Go仍然有面向对象的继承、封装和多态的特性，只是**实现方式不同**
5. Go中**面向接口编程**是非常重要的特性

### struct变量在内存中的布局
1. struct是值类型，struct变量直接指向内容空间
2. 内存对齐

### 结构体声明和使用陷阱
1. 基本语法：
    type 结构体名字 struct {
        field1 type1     // 字段
        field2 type2
    }
2. 在声明一个结构体变量后，如果没有给字段赋值，则字段是该数据类型的默认值（零值）
3. 由于结构体是值类型，所以将一个结构体变量a赋给另一个变量b后，通过b修改非引用类型的字段，
   a不会随之变化；但如果通过b修改引用类型字段，如slice, map, channel，则a相应字段也会变化

### 创建结构体实例的四种方式（假设有struct为Person）
1. var p1 Person
2. var p2 = Person{...}
3. var p3 *Person = new(Person)
    - 用new创建的实例是指针，标准是需要用取值符来访问其中的值：(*p3).Name
    - 但Go编译器有给结构体指针实例自动加上取值运算的功能，因此也可以直接p3.Name。底层会处理
4. var p4 *Person = &Person{...}
    - 和3相同，结构体指针实例

### 结构体使用注意事项和细节
1. 结构体的所有字段在内存中是连续的，同时注意有内存对齐，一般是以字长对齐
    - 但是注意如果字段类型是指针，指针指向的地址则不一定连续（存放指针的地址是连续的，但是**多个**
    指针变量指向的数据不一定是连续存放的）
2. 结构体是用户单独定义的类型，要和其他类型强制类型转换时，需要其中字段完全一样（字段名、字段个数、
   字段类型）
3. 某数据类型通过**type**重新定义（取别名），Go会将别名认为是**新的数据类型**，不能直接转换，需要强转！
4. struct的每个字段上，可以写上一个**tag**，该tag可以通过反射机制获得，常见的场景就是**序列化**和反序列化
    - 序列化：即要将类型保存的数据转换成字符串来传输，如：通过encoding/json包的Marshal()可以将类型序列化
    为json序列
5. 对结构体变量使用地址符&，并打印时，不会打印其地址，而是其值
    - fmt.Println(&p)
    - 输出: > &{...}